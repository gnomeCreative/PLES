# CONFIGURATION FILE FOR LES
# this controls only the CFD part
# Version for Example 1: laminar channel flow

# THIS IS THE OLD AGENERALE
# Discretization
n1                    = 32        # number of elements in first direction 
n2                    = 32        # number of elements in second direction 
n3                    = 32        # number of elements in third direction 

# Scalar equation
nscal			      = 1         # number of scalar equations to be solved

# Iteration / restart / print
niter                 = 1000      # number of iteration 
i_rest                = 1         # restart (0: new computation; 1: restart file "old_res_form"; 2: dns interpolation; 3: nesting)
print_iter_or_time    = 0         # (0:print every i_print; 1: print every i_time)
i_print               = 500       # print the flow field every i_print iteration "new_res"
i_time                = 0         # print the flow field every i_time seconds "new_res"
i_printfile           = 0         # type of file (0: one new_res, 1: one new_res trough mpi; 2: new_res for each procs; 3:Paraview file, parallel)
i_paraview            = 1         # print also Paraview file (0: no, 1: yes)
i_cumulative          = 1         # for time average (0: medie written on time window; 1: medie written for the total time)
iformat_newres        = 1         # format new_res (0: format *, 1: read a format; 2: binary) iprint_file=1 only binary
iformat_grid          = 0         #
ifolder               = 1         #
inf                   = 0         # print inflow plane (1: yes; 0: no) see "Apianisonde.in" to define the planes

# Characteristic numbers
re                    = 20000.0   # Reynolds (1/viscosity, molecular)
rich                  = 0.0       # Richardson ( 0.0 == passive scalar)

# Time
ind_cou              = 1          # (1: constant courant; 0: fixed delta t)
cou                  = 0.5        # courant number  (only if ind_cou = 1)
dt                   = 0.5        # passo temporale (only if ind_cou = 0)
espl                 = 0          # time advancment (1:explicit AB; 0:semimplicit AB+CN)

# Numerical scheme / equations to solve
attiva_scal          = 0          # (1:solve scalar eq. (like density); 0: no scalar eq.; specify the number of scalars in "scala3.h")
potenziale           = 0          # potential flow (1: yes; 0: no)
insc                 = 0          # spatial derivative scheme(2: SMART; 1: QUICK; 0: central difference)

# Pressure condition / pressure solver 
om_pre               = 1.6        # relaxation factor
jpos                 = 1          # pressure solver (1: sor/slor+multigrid, 0: sor)
islor                = 0          # line sor in eta and sor for csi/zeta (1:slor; 0:sor) only with jpos=1
nlevmultimax         = 4          # multigrid levels from 1 to 4
bbx                  = 1.0        # pressure gradient direction csi
bby                  = 0.0        # pressure gradient direction eta
bbz                  = 0.0        # pressure gradient direction zita
eps                  = 1e-8       # residual error for poisson (go out from cycle)
ficycle              = 1000       # max cycle number for poisson (go out from cycle) 50
bodypressure         = 0          # ibm correction for pressure (1: on; 0: off) needs bodyforce=1
ipress_cart          = 0          # =1 uses poisson in cartesian form
freesurface          = 0          # free surface at top surface (side4)

# Boundary condition (see also Aboundary.in) 
lett                 = 0          # open boundary (1: on; 0: off) see Aboundary.in
ibb                  = 0          # apply bodyforce on buffer (0:off, 1:on) see Aboundary.in
bodyforce            = 0          # immersed boundary (1: on; 0: off)
num_iter             = 4          # interpolation cycle on ib (IBM) for taylor series (only if bodyforce = 1)
coef_wall            = 1          # wall function (1: on; 0: off; 2:ibm)
integrale            = 0          # DO NOT USE option WF with WernerWengle (1: integral; 0 point)
rough                = 0          # flat wall or rough wall (0: flat; 1: rough) only if coef_wall > 0
z0                   = 0.001      # roughness, only if coef_wall > 0
att_wm_sgs           = 1          # correction on sgs close to the wall (1: on; 0; off)

# Turbulence model
nsgs                 = 1          # sgs model (3:lagr smagorinsky; 2: dynamic smagorinsky; 1: static smagorinsky; 0: DNS)
inmod                = 0          # scale similar (1: on; 0: off)
inmodrho             = 0          # scale similar for scalar transport (1: on; 0: off)
isotropo             = 1          # anisotropic/isotropic sgs (0: two eddy viscosity, 1: one eddy viscosity)
cost                 = 0.090      # constant for isotropic static model 
costH                = 0.100      # constant for anisotropic static model, horizontal (direction (1 and 3 or csi and zeta) )
costV                = 0.100      # constant for anisotropic static model, vertical   (direction (2 or eta) )

# Forcing
indm                 = 0          #
windyes              = 0          #
wavebk               = 0          #
alpha                = 0.0        #
c10                  = 0.0        #
l_0                  = 1.0        #
langyes              = 0          #
lamb                 = 12.        #
h_0                  = 0.0        #
A1                   = 0.0        #
A2                   = 0.0        #
A3                   = 0.0        #
U0                   = 0.0        #
V0                   = 0.0        #
W0                   = 0.0        #
LATITUDE             = 0.0        #
omegaM2              = 0.0        #

# Other
visualizzo           = 1          # DO NOT USE visualization of some informations
lagr                 = 1          # DO NOT USE (0: scrive output omogeneo,1 no)
i_sta                = 5          # DO NOT USE (stampa porzione campo) (?COSE ANNA)
 
# Movies
imovie               = 0          # print movie (=0 no; =1 yes in ktime; =2 yes in dt_time)
ktime_movie          = 10         # print every ktime_movie iterations
dt_movie             = 0.1        # print every dt_movie seconds
dt_delay             = 0.0        # delay with respect to previous run for movie
i_movie              = 32         # index for jk plane 
j_movie              = 10         # index for ik plane
k_movie              = 32         # index for ij plane

# THIS IS THE OLD ABOUNDARY
ip                   = 0          # periodicity in csi   (1:no; 0:yes) direction(1-2)
jp                   = 1          # periodicity in eta   (1:no; 0:yes) direction(3-4)
kp                   = 0          # periodicity in zita  (1:no; 0:yes) direction(5-6)
infout1              = 2          # plane 1 (0:inflow; 1:open boundary; 2: no slip/free slip)
infout2              = 2          # plane 2 (0:inflow; 1:open boundary; 2: no slip/free slip)
infout3              = 2          # plane 3 (0:inflow; 1:open boundary; 2: no slip/free slip)
infout4              = 2          # plane 4 (0:inflow; 1:open boundary; 2: no slip/free slip)
infout5              = 2          # plane 5 (0:inflow; 1:open boundary; 2: no slip/free slip)
infout6              = 2          # plane 6 (0:inflow; 1:open boundary; 2: no slip/free slip)
iboun1               = 0          # wall 1 ( 0: no slip; 1:free slip; 2: nesting)
iboun2               = 0          # wall 2 ( 0: no slip; 1:free slip; 2: nesting)
iboun3               = 0          # wall 3 ( 0: no slip; 1:free slip; 2: nesting)
iboun4               = 0          # wall 4 ( 0: no slip; 1:free slip; 2: nesting)
iboun5               = 0          # wall 5 ( 0: no slip; 1:free slip; 2: nesting)
iboun6               = 0          # wall 6 ( 0: no slip; 1:free slip; 2: nesting)
wfp1                 = 0          # wall 1 (1:wall function, 0: no slip)
wfp2                 = 0          # wall 2 (1:wall function, 0: no slip)
wfp3                 = 1          # wall 3 (1:wall function, 0: no slip)
wfp4                 = 1          # wall 4 (1:wall function, 0: no slip)
wfp5                 = 0          # wall 5 (1:wall function, 0: no slip)
wfp6                 = 0          # wall 6 (1:wall function, 0: no slip)
ibodybuffer1         = 0          # buffer side 1 (0:nothing, 1: local bodyforce)
ibodybuffer2         = 0          # buffer side 2 (0:nothing, 1: local bodyforce)
ibodybuffer3         = 0          # buffer side 3 (0:nothing, 1: local bodyforce)
ibodybuffer4         = 0          # buffer side 4 (0:nothing, 1: local bodyforce)
ibodybuffer5         = 0          # buffer side 5 (0:nothing, 1: local bodyforce)
ibodybuffer6         = 0          # buffer side 6 (0:nothing, 1: local bodyforce)
ispon                = 10         # sponge in i-direction
kspon                = 10         # sponge in k-direction (note: cannot be larger than jz/nproc)
corr_factor          = 100.0      # correlation time for coloured disturbance

# THIS IS THE OLD ASCALARE
re_analogy           = 1          # =1 reynolds analogy on, = 0 off
[1]
pran                 = 0.7        # prandtl number scalar
prsc                 = 0.8        # prandtls sgs scalar used if re_analogy=1
[]
imoist               = 0          # moisture procedure (0=off; 1=on)
Tref                 = 301.6      # reference value for temperature
Qref                 = 0.0        # reference value for humidity
betaT                = 0.003      # 1/k, order 0.003 1/Tref
betaQ                = 0.608      # non-dim, if q-->0, (Ma/Mv)-1
Ma                   = 28.966     # molar mass dry air
Mv                   = 18.015     # molar mass water vapor
Lv                   = 2.4e6      # evaporation latent heat
Gdry                 = 9.80e-3    # 
Rd                   = 286.9      # dry air constant
cpd                  = 1005.      # dry air specific heat J/K kg

# THIS IS THE OLD APIANISONDE
npiani  		     = 2          # number of plane to print
[1]
piani   		     = 10         # number of plane to print
[]

nsonde  		     = 0           # number of plane to print
[1]
indexi   		     = 5          #
indexj   		     = 6          # 
indexk   		     = 8          #
[]

# THIS IS THE OLD AFILTRAGGIO
ifiltro              = 0          # 1: filtering; 0: no filtering
nfiltro              = 50         # How many iteration between two consecutive filterings

filtrou              = 1          # 1: filtering u component; 0: inactive
filtrov              = 1          # 1: filtering v component; 0: inactive
filtrow              = 1          # 1: filtering w component; 0: inactive
filtrorho            = 1          # 1: filtering rho component; 0: inactive
filtrofi             = 1          # 1: filtering fi component; 0: inactive

xstart               = 1          # initial index for filtering in x
xend                 = 100        # final index for filtering in x
ystart               = 1          # initial index for filtering in y
yend                 = 100        # final index for filtering in y
zstart               = 1          # initial index for filtering in z
zend                 = 100        # final index for filtering in z






























